项目名：Try to Implement this scheme
一、实验目标：
在本次实验中我们使用泛化哈希链实现验证一个秘密数secret在某个区间[a,b]内。
二、实验流程：
	选择一个合适的区间[a, b]，表示想要证明的秘密整数x的范围。
选择一个合适的哈希函数族{H_k | k是任意整数}
需要生成一个初始值seed，，它可以是任意的字符串或数字。计算出x在区间[a, b]中对应的二进制表示b_x，并且将其分成n个比特位b_x[0], b_x1, …, b_x[n-1]。
根据b_x中每个比特位的值来选择不同的参数k，并且用它们来构造一个泛化哈希链。具体地说，如果b_x[i]=0，那么您就选择k=2i；如果b_x[i]=1，选择k=-2i。然后，可以用这些参数k来生成n个哈希值h_0, h_1, …, h_n-1，其中h_i = H_k(s)。如果b_x=101010，并且s=“hello”，那么h_0 = SHA-256–1(“hello”)；h_1 = SHA-256–2(“hello”)；h_2 = SHA-256-4(“hello”)；h_3 = SHA-256–8(“hello”)；h_4 = SHA-256-16(“hello”)；h_5 = SHA-256–32(“hello”)。
将种子s和n个哈希值h_0, h_1, …, h_n-1组成一个证明p，并且将其发送给验证者。验证者可以根据以下方法来验证证明p：
首先，验证者需要知道区间[a, b]和哈希函数族{H_k | k是任意整数}。
然后，验证者需要从证明p中提取出种子s和n个哈希值h_0, h_1, …, h_n-1。
接下来，验证者需要根据哈希值h_0, h_1, …, h_n-1来重构出b_x中每个比特位的值。如果h_i = H_k(s)，那么验证者就可以根据k的正负号来判断b_x[i]的值。如果k>0，那么b_x[i]=0；如果k<0，那么b_x[i]=1。
最后，验证者需要根据b_x中的二进制表示来计算出x的值，并且检查是否满足x在区间[a, b]中。
三、实验操作：
在实验中我们选择了python自带的hashlib库中的SHA-256作为哈希函数。通过将seed与二进制数k相异或得到一系列的哈希函数族。
def hash_encode(s,k):
    # 创建一个SHA-256哈希对象
    m = hashlib.sha256()
        # 向哈希对象中添加数据
    m.update(bxor(s,k).encode())
    # 获取哈希值
    h = m.digest()
    # 将哈希值转换为16进制字符串
    d = m.hexdigest()
    #打印哈希值的16进制
    print("0x",d,"\n")
    return d
生成b_x时我们采用srcert在区间[a,b]的相对位置的二进制，并取log(b,2)的下界为位数n，表示要表示b_x需要的位数。
之后生成一系列的哈希链。
在比较时我们选择比较正确返回’0’，失败则返回’1’，从而实现对b_x的还原。要注意的是，此时验证者并不能知道secret具体是哪一个数。
